fx = function(x^n/(b^n+x^n))
fx(x,n,b) = function(x^n/(b^n+x^n))
fx(x,n,b) = function(x**n/(b**n+x**n))
fx = function(x,n,b){x**n/(b**n+x**n)}
x = seq(1:100)
fx = function(x,n,b){x**n/(b**n+x**n)}
x_value = seq(1:100)
table = data.frame()
for(i in x_value){
d = data.frame(x = i,
fx_n1 = fx(i,1,2),
fx_n2 = fx(i,2,2),
fx_n3 = fx(i,3,2))
table = rbind(table,d)
}
View(table)
plot(table)
plot(table$x, table$fx_n1)
plot(table$x, table$fx_n1, type = l)
plot(table$x, table$fx_n1, type = "l")
plot(table$x, table$fx_n2, type  "l")
par(mfrow(2,2))
plot(table$x, table$fx_n1, type = "l")
plot(table$x, table$fx_n2, type = "l")
plot(table$x, table$fx_n3, type = "l")
par(mfrow=c(2,2))
plot(table$x, table$fx_n1, type = "l")
plot(table$x, table$fx_n2, type = "l")
plot(table$x, table$fx_n3, type = "l")
par(mfrow=c(1,1))
plot(table$x, table$fx_n1, type = "l", col =1)
line(table$x, table$fx_n2, col = 2)
line(table$x, table$fx_n3, col = 3)
line(table$x, table$fx_n2, col = 2)
View(table)
lines(table$x, table$fx_n2, col = 2)
lines(table$x, table$fx_n3, col = 3)
x_value = seq(1:100)
fx_n1 = fx(i,1,2)
fx_n2 = fx(i,2,2)
fx_n3 = fx(i,3,2)
lines(x, fx_n1)
lines(x, fx_n1)
fx_n1 = fx(x,1,2)
fx_n2 = fx(x,2,2)
fx_n3 = fx(x,3,2)
lines(x, fx_n1)
lines(x, fx_n2, col = 2)
lines(x, fx_n3, col = 3)
fx_n1 = fx_n2
fx_n1 = fx(x,1,2)
fx_n2 = fx(x,2,2)
fx_n3 = fx(x,3,2)
lines(x, fx_n1)
lines(x, fx_n2, col = 2)
lines(x, fx_n3, col = 3)
# #Output csv
# write.csv(School_fit, "../results/School_fit.csv", row.names = F)
# #Import csv
School_fit = read.csv("../results/School_fit.csv", header =T)
rm(list=ls())
graphics.off()
library(minpack.lm)
library(ggplot2)
library(reshape2)
library(grid)
print("Data processing...")
data = read.csv("../data/ThermRespData.csv")
# Store all possible relevant information in a new data frame
cData = data.frame(data$ID,data$StandardisedTraitName, data$OriginalTraitValue, data$OriginalTraitUnit,data$Consumer, data$Habitat, data$Location, data$ConStage, data$ConTemp)
names(cData) = c("ID", "trait_name", "trait_value", "trait_unit","consumer", "habitat", "location", "stage", "temp")
cData = cData[-which(cData$trait_value < 0),] # Getting rid of negative trait values
cData$temp = as.numeric(cData$temp)
cData$trait_name[cData$trait_name == "gross photosynthesis rate" | cData$trait_name == "net photosynthesis rate"] = "photosynthesis rate"
print("Done!")
for(i in unique(cData$ID)){
datai = subset(cData, cData$ID== i) #Data subset for iteration
if(nrow(datai) >= 5) x = c(x, i) # ID with more than 5 data points
#Fitting the quadratic
plm2 = try(lm(trait_value ~poly(temp,2), data = datai), silent = T) #Fitting the quadratic model
if(class(plm2) != "try-error"){
summ = summary(plm2)
RSS_i = sum(residuals(plm2)^2) # Residual sum of squares
n = nrow(datai) # sample size
p_i = length(coef(plm2)) # Number of parameters
AICc_i = n+2+n*log((2*pi)/n)+n*log(RSS_i) + 2*p_i*(n/(n-p_i-1))
dataframe = data.frame( #Outputing the model fitting dataframe
ID = i, consumer = unique(datai$consumer), trait_name = unique(datai$trait_name),
r2 = summ$r.squared, a = summ$coefficients[2], b = summ$coefficients[3], intercept = summ$coefficients[1],
AIC = AIC(plm2), AICc = AICc_i, BIC = BIC(plm2),
habitat = unique(datai$habitat), location = unique(datai$location), stage = unique(datai$stage)
)
lm2_model_fitting = rbind(lm2_model_fitting, dataframe) #Combining dataframe
}
#Fitting the cubic
plm3 = try(lm(trait_value ~poly(temp,3),data = datai), silent = T) #Fitting the cubic model
if(class(plm3) != "try-error"){
summ = summary(plm3)
RSS_i = sum(residuals(plm3)) # Residual sum of squares
n = nrow(datai) # sample size
p_i = length(coef(plm3)) # Number of parameters
AICc_i = n+2+n*log((2*pi)/n)+n*log(RSS_i) + 2*p_i*(n/(n-p_i-1))
dataframe = data.frame( #Outputing the model fitting dataframe
ID = i, consumer = unique(datai$consumer), trait_name = unique(datai$trait_name),
r2 = summ$r.squared, a = summ$coefficients[2], b = summ$coefficients[3], c = summ$coefficients[4], intercept = summ$coefficients[1],
AIC = AIC(plm3), AICc = AICc_i, BIC = BIC(plm3),
habitat = unique(datai$habitat), location = unique(datai$location), stage = unique(datai$stage))
lm3_model_fitting = rbind(lm3_model_fitting, dataframe) #Combining dataframe
}
#  print(i) # The progress bar~~
}
print("Done!")
###########Fitting Schoolfield model###################
## Defining Schoolfield model function
Schoolfield = function(tran_kT, lnB0, Th, Ea, Eh){
return(lnB0+(tran_kT+1/(283.15*k))*Ea-log(1+exp((1/(Th*k)+tran_kT)*Eh)))
}
## Fitting lnB ~ -1/k*(1/T-1/283.15) as linear model (Arrhenius)
## intercept = lnB0, slope = Ea
k = 8.61*10^(-5)
# Creating a new data frame for school field model fitting
sch_cData = cData
sch_cData$lnB = log(sch_cData$trait_value)
sch_cData$temp = sch_cData$temp+273.15
sch_cData$tran_kT = -1/(k*sch_cData$temp)
sch_cData$tran_kTT = sch_cData$tran_kT+1/(283.15*k)
sch_cData = sch_cData[-which(sch_cData$lnB == -Inf),]
# Fitting Arrhenius, dividing all data with before and after deactivation;
# get estimation values(possible starting values) on A0(B0) and Ea
ID = c(); consumer = c(); stage= c(); trait_name = c(); Th = c(); lnA0 = c(); Ea = c(); Eh = c();
r2_befdeact = c(); r2_deact = c(); before = c(); after = c(); n = 0
for(i in unique(sch_cData$ID)){
datai = sch_cData[sch_cData$ID == i,] # Data subset for iteration
if(nrow(datai) > 3){
#get the data to fit
T_lnB_max = datai$temp[datai$lnB == max(datai$lnB)] # Deactivation temperature
datai_befdeact = subset(datai, temp <= T_lnB_max) # Data before deactivation
datai_deact = subset(datai, temp >= T_lnB_max) # Data after deactivation
temph = max(datai_befdeact$temp)
if(nrow(datai_befdeact)>1){ # At least two data points to fit a linear
lm_sch_befdeact = lm(lnB~tran_kTT, data = datai_befdeact)
summ_befdeact = summary(lm_sch_befdeact)
lnA0 = c(lnA0, summ_befdeact$coefficients[1])
Ea_value = summ_befdeact$coefficients[2]
r2_befdeact = c(r2_befdeact, round(summ_befdeact$r.squared, digits = 4))
}else{ # Give an estimation if only one point
lnA0 = c(lnA0, max(datai$lnB))
Ea_value = 0.5
r2_befdeact = c(r2_befdeact,NaN)
before = c(before, i)}
Ea = c(Ea, Ea_value)
if(nrow(datai_deact)>1){ # At least two data points to fit a linear
n = n+1 #How many have a deactivation point?
lm_sch_deact = lm(lnB~tran_kTT, data = datai_deact)
summ_deact = summary(lm_sch_deact)
Eh = c(Eh, -summ_deact$coefficients[2])
r2_deact = c(r2_deact, round(summ_deact$r.squared, digits = 4))
}else{ # Give an estimation if only one point
Eh = c(Eh,4*Ea_value)
r2_deact = c(r2_deact,NaN)
after = c(after, i)}
ID = c(ID, i)
consumer = c(consumer, unique(datai$consumer))
stage = c(stage, unique(datai$stage))
trait_name = c(trait_name, unique(datai$trait_name))
Th = c(Th, temph)
}
}
Arrhenius = data.frame(ID, consumer, stage, trait_name, Th, lnA0, Ea, Eh,r2_befdeact, r2_deact)
View(Arrhenius)
l = c(1,2,3)
class(l)
dim(1)
M <- matrix(runif(1000000),1000,1000)
dim(M)
TreeHeight <- function(degrees, distance){
radians <- degrees * pi / 180
height <- distance * tan(radians)
print(paste("Tree height is:", height))
return (height)
}
TreeHeight(37, 40)
a = TreeHeight(37, 40)
a
apply(M, 1, mean)
M = 10
apply(M, 1, mean)
M <- matrix(rnorm(100), 10, 10)
apply(M, 1, mean)
apply
?apply
M <- matrix(rnorm(100), 10, 10)
M
View(M)
M <- matrix(rnorm(25), 5, 5)
View(M)
apply(M, 1, mean)
mean(M[1:])
mean(M[1])
mean(M[1, :])
mean(M[1,])
mean(M[2,])
apply(M, 2, mean)
mean(M[,1])
?lapply
sigma = 0.2
ran = rnorm(1000, 0, sigma)
ran[1]
ran[1]
ran[2]
ran[3]
ran[4]
?factor
?rep
?sample_n
??sample_n
library(ggplot2)
library(minpack.lm)
install.packages("ggplot2")
install.packages('minpack.lm')
install.packages('vegan')
install.packages('minpack.lm')
install.packages('reshape2')
library(grid)
library(minpack.lm)
library(ggplot2)
library(reshape2)
library(grid)
# Question 1
species_richness <- function(community = c(1,4,4,5,1,6,1)){
return(length(unique(community)))
}
# Question 2
init_community_max <- function(size = 7){
return(seq(from = 1, to = size, by = 1))
}
# Question 3
init_community_min <- function(size = 4){
return(rep(1, times = size))
}
# Question 4
choose_two <- function(max_value = 4){
return(sample(max_value,2, replace = F))
}
# Question 5
neutral_step <- function(community = c(10,5,13)){
index = choose_two(length(community))
community[index[1]] = community[index[2]] #Replacing the dead with reproduction
return(community)
}
# Question 6
neutral_generation <- function(community = c(1,5,2,6,8,13,25)){
# For x individuals, x/2 individual neutral steps for a complete generation
for(i in 1:floor(length(community)/2)) community = neutral_step(community)
return(community)
}
# Question 7
neutral_time_series <- function(community = init_community_max(7) , duration = 20)  {
richness = c(species_richness(community))
for(i in 1:duration){
community = neutral_generation(community) # Current community
richness = c(richness, species_richness(neutral_generation(community)))
}
return(richness)
}
# Question 8
question_8 <- function() {
richness = neutral_time_series(community = init_community_max(100), duration = 200) # Running the simulation for 200 generations
graphics.off()# clear any existing graphs and plot your graph within the R window
plot(richness, type = "l", frame.plot = F, ylab = "Diversity", xlab = "Generation", main = "Time Series Graph of a Neutral Model Simulation")
abline(h = 1, lty = 3)
text(x = 160, y = 17.5, "Converging to diversity = 1")
return("If we wait long enough, the diversity will always converge to 1. Since in this system, all species are considered with same possibility for reproduction and replacement without speciation or new species being introduced, as one species' abundance increases, the probability of reproduction of that species would also increase, therefore the system will finally result in the homogeneity of species.")
}
# Question 9
neutral_step_speciation <- function(community = c(10,5,13), speciation_rate = 0.2)  {
index = choose_two(length(community))
rate = runif(1)
if(rate < speciation_rate){
community[index[1]] = max(community) + 1 # Replacing a dead individual with a new species
}else{
community[index[1]] = community[index[2]] #Replacing a dead individual with an offspring
}
return(community)
}
# Question 10
neutral_generation_speciation <- function(community = c(10,5,13), speciation_rate = 0.2)  {
for(i in 1:floor(length(community)/2)) community = neutral_step_speciation(community, speciation_rate)
return(community)
}
# Question 11
neutral_time_series_speciation <- function(community = init_community_max(100), speciation_rate = 0.1, duration = 500)  {
richness = c(species_richness(community))
for(i in 1:duration){
community = neutral_generation_speciation(community, speciation_rate) #Current community
richness = c(richness, species_richness(neutral_generation_speciation(community, speciation_rate)))
}
return(richness)
}
# Question 12
question_12 <- function()  {
richness_max = neutral_time_series_speciation(community = init_community_max(100), speciation_rate = 0.1, duration = 200)
richness_min = neutral_time_series_speciation(community = init_community_min(100), speciation_rate = 0.1, duration = 200)
graphics.off()# clear any existing graphs and plot your graph within the R window
plot(richness_max, frame.plot = F, type = "l", pch = 1, cex = 0.75, col = 1, ylim = c(0,100), ylab = "Diversity", xlab = "Generation", main = "Time Series Graph of a Neutral Model Simulation")
lines(richness_min, pch = 1, cex = 0.75, col = 2)
legend('topright', c('richness_max','richness_min'), fill = c(1,2), bty = "n")
return("Given time, the final convergence of diversity is determined by the speciation rate and the initial size of the community, but not related to the initial diversity of the system. Because when the rate of extinction is balanced by the rate of speciation, the diversity of this system will reach a dynamic equilibrium.")
}
# Question 13
species_abundance <- function(community = c(1,5,3,6,5,6,1,1))  {
return(sort(as.data.frame(table(community))[,2],decreasing = T)) # Getting frequencies and sort in descending order
}
# Question 14
octaves <- function(abundance_vector = c(100,64,63,5,4,3,2,2,1,1,1,1)) {
return(tabulate(floor(log2(abundance_vector))+1)) #Binning abundances into frequencies in 2^n
}
octaves(abundance_vector = c(100,64,63,5,4,3,2,2,1,1,1,1))
abundance_vector = c(100,64,63,5,4,3,2,2,1,1,1,1)
log2(abundance_vector)
floor(log2(abundance_vector))+1)
floor(log2(abundance_vector))+1
tabulate(floor(log2(abundance_vector))+1)
floor(log2(abundance_vector))+1
tabulate(floor(log2(abundance_vector))+1)
log2(abundance_vector)
floor(log2(abundance_vector))
floor(log2(abundance_vector))+1
tabulate(floor(log2(abundance_vector))+1)
?log2
log(2,abundance_vector)
log2(abundance_vector)
# Question 9
neutral_step_speciation <- function(community = c(10,5,13), speciation_rate = 0.2)  {
index = choose_two(length(community))
rate = runif(1)
if(rate < speciation_rate){
community[index[1]] = max(community) + 1 # Replacing a dead individual with a new species
}else{
community[index[1]] = community[index[2]] #Replacing a dead individual with an offspring
}
return(community)
}
neutral_step_speciation(community = c(10,5,13), v= 0.2)
neutral_step_speciation(community = c(10,5,13), v)
v = 0.2
neutral_step_speciation(community = c(10,5,13), v)
neutral_step_speciation(community = c(10,5,13), v)
neutral_step_speciation(community = c(10,5,13), v)
neutral_step_speciation(community = c(10,5,13), v)
neutral_step_speciation(community = c(10,5,13), v)
neutral_step_speciation(community = c(10,5,13), v)
neutral_step_speciation(community = c(10,5,13), v)
neutral_step_speciation(community = c(10,5,13), v)
neutral_step_speciation(community = c(10,5,13), v)
# Question 16
question_16 <- function()  {
octave_max = 0
octave_min = 0
community_max = init_community_max(100) # Community with 100 individuals
community_min = init_community_min(100)
for(i in 1:2200){
community_max = neutral_generation_speciation(community = community_max, speciation_rate = 0.1) #Current community
community_min = neutral_generation_speciation(community = community_min, speciation_rate = 0.1)
if(i >= 200 & (i-200) %% 20 == 0){
abundance_max = species_abundance(community_max)
octave_max = sum_vect(octave_max, octaves(abundance_max)) # Sum up all the octaves since the end of burn-in
abundance_min = species_abundance(community_min)
octave_min = sum_vect(octave_min, octaves(abundance_min))
}
}
octave_max_mean = octave_max/101 # Calculating the average of all octaves
octave_min_mean = octave_min/101
data = rbind(octave_max_mean,octave_min_mean)
colnames(data) = c("1","2-3","4-7","8-15","16-31","32-64")
graphics.off()# clear any existing graphs and plot your graph within the R window
barplot(data, beside = T, ylab = "Number of Species", ylim = c(0,11), xlab = "Species Abundance", main = "Species Abundance Octave of Neutral Model Simulation",col = c(0,1))
legend("topright", c("octave_max", "octave_min"), fill = c(0,1), bty = "n")
return("Initial condition of the system does not matter, since this calculation was conducted after the system has already reached its dynamic equilibrium which is related to the speciation rate.")
}
# Question 9
neutral_step_speciation <- function(community = c(10,5,13), speciation_rate = 0.2)  {
index = choose_two(length(community))
rate = runif(1)
if(rate < speciation_rate){
community[index[1]] = max(community) + 1 # Replacing a dead individual with a new species
}else{
community[index[1]] = community[index[2]] #Replacing a dead individual with an offspring
}
return(community)
}
# Question 10
neutral_generation_speciation <- function(community = c(10,5,13), speciation_rate = 0.2)  {
for(i in 1:floor(length(community)/2)) community = neutral_step_speciation(community, speciation_rate)
return(community)
}
# Question 11
neutral_time_series_speciation <- function(community = init_community_max(100), speciation_rate = 0.1, duration = 500)  {
richness = c(species_richness(community))
for(i in 1:duration){
community = neutral_generation_speciation(community, speciation_rate) #Current community
richness = c(richness, species_richness(neutral_generation_speciation(community, speciation_rate)))
}
return(richness)
}
# Question 12
question_12 <- function()  {
richness_max = neutral_time_series_speciation(community = init_community_max(100), speciation_rate = 0.1, duration = 200)
richness_min = neutral_time_series_speciation(community = init_community_min(100), speciation_rate = 0.1, duration = 200)
graphics.off()# clear any existing graphs and plot your graph within the R window
plot(richness_max, frame.plot = F, type = "l", pch = 1, cex = 0.75, col = 1, ylim = c(0,100), ylab = "Diversity", xlab = "Generation", main = "Time Series Graph of a Neutral Model Simulation")
lines(richness_min, pch = 1, cex = 0.75, col = 2)
legend('topright', c('richness_max','richness_min'), fill = c(1,2), bty = "n")
return("Given time, the final convergence of diversity is determined by the speciation rate and the initial size of the community, but not related to the initial diversity of the system. Because when the rate of extinction is balanced by the rate of speciation, the diversity of this system will reach a dynamic equilibrium.")
}
# Question 13
species_abundance <- function(community = c(1,5,3,6,5,6,1,1))  {
return(sort(as.data.frame(table(community))[,2],decreasing = T)) # Getting frequencies and sort in descending order
}
# Question 14
octaves <- function(abundance_vector = c(100,64,63,5,4,3,2,2,1,1,1,1)) {
return(tabulate(floor(log2(abundance_vector))+1)) #Binning abundances into frequencies in 2^n
}
# Question 15
sum_vect <- function(x = c(1,3), y = c(1,0,5,2)) {
if(length(x) < length(y)){ # If x is shorter, add 0s to the end of x
x = c(x, rep(0, (length(y)-length(x))))
}else{ # If y is shorter, add 0s to the end of y
y = c(y, rep(0, (length(x)-length(y))))
}
return(x+y)
}
question_16()
# Question 16
question_16 <- function()  {
octave_max = 0
octave_min = 0
community_max = init_community_max(100) # Community with 100 individuals
community_min = init_community_min(100)
for(i in 1:2200){
community_max = neutral_generation_speciation(community = community_max, speciation_rate = 0.1) #Current community
community_min = neutral_generation_speciation(community = community_min, speciation_rate = 0.1)
if(i >= 200 & (i-200) %% 20 == 0){
abundance_max = species_abundance(community_max)
octave_max = sum_vect(octave_max, octaves(abundance_max)) # Sum up all the octaves since the end of burn-in
abundance_min = species_abundance(community_min)
octave_min = sum_vect(octave_min, octaves(abundance_min))
}
}
octave_max_mean = octave_max/101 # Calculating the average of all octaves
octave_min_mean = octave_min/101
data = rbind(octave_max_mean,octave_min_mean)
colnames(data) = c("1","2-3","4-7","8-15","16-31","32-64")
graphics.off()# clear any existing graphs and plot your graph within the R window
barplot(data, beside = T, ylab = "Number of Species", ylim = c(0,11), xlab = "Species Abundance", main = "Species Abundance Octave of Neutral Model Simulation",col = c(0,1))
legend("topright", c("octave_max", "octave_min"), fill = c(0,1), bty = "n")
return("Initial condition of the system does not matter, since this calculation was conducted after the system has already reached its dynamic equilibrium which is related to the speciation rate.")
}
setwd("../../../1yr_project/code")
download.packages("flowViz")
install.packages("flowViz")
update.packages(checkBuilt=TRUE, ask=FALSE)
update.packages("tidyr")
install.packages("tidyr")
update.packages(ask = F)
install.packages("http://cran.r-project.org/src/contrib/Archive/nloptr/nloptr_1.0.0.tar.gz", repos=NULL, type="source")
update.packages(ask = F)
install.packages("nloptr")
install.packages("flowViz")
install.packages("flowViz", dependencies = T)
if (!require("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("flowViz")
BiocManager::install(version='devel')
R.version
BiocManager::install(version = '3.14')
BiocManager::install(version = '3.14')
BiocManager::install(version='devel')
R.Version()
BiocManager::install(version='devel')
BiocManager::install(version = '3.14')
install.packages("spatial")
BiocManager::install(version = '3.14')
install.packages("nloptr")
install.packages("spatial")
BiocManager::install(version='devel')
BiocManager::install(version = '3.14')
update.packages(ask = F)
install.packages("spatial")
update.packages(ask = F)
install.packages("spatial")
BiocManager::install(version = '3.14')
BiocManager::install(version = '3.14')
remove.packages("spatial")
install.packages("spatial")
BiocManager::install(version = '3.14')
BiocManager::install("flowStats")
install.packages("spatial")
update.packages("spatial")
update.packages()
update.packages("spatial")
install.packages("spatial")
update.packages()
